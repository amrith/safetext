/*
 * make-codebook.c
 *
 * Part of the 'safetext' project. This project provides a simple set
 * of libraries that will encode arbitrary blocks of data into a
 * format that resembles base64. However it also implements a simple
 * form of codebook cipher that makes it harder to guess the input
 * data from the encoded output.
 *
 * This software is provided "as-is" with no warranties either
 * implied, or otherwise, on its applicability for use in any
 * situation. If you wish to use it, you do so entirely at your own
 * risk. The author assumes no liabilities for any damages that may
 * arise from your use of this software.
 *
 * This software is licensed under the terms of the license file
 * (LICENSE) provided in the root of this repository.
 *
 * Amrith. 2019-02-24
 *
 */


#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <assert.h>

#include "codebook.h"

static void make_timestamp(FILE * fp)
{
    time_t now = time(NULL);
    char timestr[100];
    strftime(timestr, 100, "%Y-%m-%d %H:%M:%S", localtime(&now));
    fprintf (fp, " * Generated by make-codebook at %s\n", timestr);
    return;
}

#define TRANSPOSE_ITERATIONS (3000)

static void transpose(char * p)
{
    int iter, ix, iy;
    char c;
    for (iter = 0, ix = rand() % CHARSET_LENGTH, iy = rand() % CHARSET_LENGTH;
         iter < TRANSPOSE_ITERATIONS;
         ix = rand() % CHARSET_LENGTH, iy = rand() % CHARSET_LENGTH)
    {
        if (ix != iy)
        {
            c = p[ix];
            p[ix] = p[iy];
            p[iy] = c;
            iter ++;
        }
    }

    return;
}

static void make_codebook_entry (FILE * fp, char * alphabet)
{
    int ix;
    fprintf(fp, "    { \"%s\",\n", alphabet );
    for (ix = 0; ix < CHARSET_LENGTH; ix ++)
    {
        int iy;
        for (iy = 0; iy < CHARSET_LENGTH && alphabet[iy] != CHARSET[ix]; iy ++)
            ;

        assert(alphabet[iy]);
        if (ix == 0)
            fprintf (fp, "    {");
        else if (ix % 16 == 0)
            fprintf (fp, "\n     ");

        fprintf (fp, " %2d", iy );
        if (ix != CHARSET_LENGTH-1)
            fprintf (fp, ",");
        else
            fprintf (fp, "}}");
    }
}

static void make_codebook(FILE * fp)
{
    int ix;
    char alphabet[CHARSET_LENGTH+1];

    fprintf (fp, "codebook_t codebook[] = {\n" );
    for (ix = 0; ix < CODEBOOK_SIZE; ix ++)
    {
        strcpy (alphabet, CHARSET);
        transpose(alphabet);
        fprintf (fp, "    /* %d */\n", ix );
        make_codebook_entry(fp, alphabet);

        if (ix != CODEBOOK_SIZE-1)
            fprintf(fp, ",\n\n");
        else
            fprintf(fp, "\n");
    }

    fprintf (fp, "};\n\n");
}

void make_switch (FILE * fp)
{
    int ix;
    fprintf (fp, "   switch(c)\n");
    fprintf (fp, "   {\n");
    for (ix = 0; ix < CHARSET_LENGTH; ix ++)
    {
        fprintf (fp, "      case '%c': return %d;\n", CHARSET[ix], ix );
    }
    fprintf (fp, "      default: fprintf ( stderr, \""\
             "ERROR: charix(%%c)\\n\", c); exit(1);\n");
    fprintf (fp, "   }\n");
}

int main ()
{
    FILE * ifp = fopen ("codebook.in", "r");
    FILE * ofp = fopen ("codebook.c", "w");
    char buffer[512+1];
    int b;

    while (!feof(ifp))
    {
        if (fgets(buffer, 512, ifp) == NULL)
            continue;

        if (!strcmp(buffer, "@@codebook\n"))
        {
            make_codebook(ofp);
        }
        else if (!strcmp(buffer, " * @@timestamp\n"))
        {
            make_timestamp(ofp);
        }
        else if (!strcmp(buffer, "@@SWITCH\n"))
        {
            make_switch(ofp);
        }
        else
        {
            fprintf(ofp, "%s", buffer);
        }
    }

    fclose (ifp);
    fclose (ofp);
    return 0;
}
